/**
 * Structural Analysis Parser
 *
 * Extracts structural analysis JSON from generated HTML scenes.
 * The AI embeds analysis in an HTML comment in this format:
 * <!-- STRUCTURAL_ANALYSIS: {...} -->
 *
 * @see Story 2.6: Add Structural Feedback for Generated Models
 */

import type { StructuralAnalysisResult, StructuralIssue } from './structural-analysis';

/**
 * Regex to match the structural analysis HTML comment.
 * Uses non-greedy matching and the 's' flag for multiline JSON.
 */
const ANALYSIS_REGEX = /<!-- STRUCTURAL_ANALYSIS: (\{[\s\S]*?\}) -->/;

/**
 * Validates that an issue object has the required shape.
 */
function isValidIssue(issue: unknown): issue is StructuralIssue {
    if (typeof issue !== 'object' || issue === null) return false;
    const obj = issue as Record<string, unknown>;
    return (
        typeof obj.type === 'string' &&
        typeof obj.severity === 'string' &&
        typeof obj.message === 'string' &&
        typeof obj.suggestion === 'string'
    );
}

/**
 * Parses structural analysis from a generated HTML scene.
 *
 * Extracts the JSON embedded in the <!-- STRUCTURAL_ANALYSIS: {...} --> comment
 * and validates the structure before returning.
 *
 * @param htmlScene - The complete HTML scene generated by the AI
 * @returns The parsed analysis result, or null if not found/invalid
 *
 * @example
 * ```typescript
 * const analysis = parseStructuralAnalysis(generatedHtml);
 * if (analysis && !analysis.isStable) {
 *   showWarning(analysis.issues);
 * }
 * ```
 */
export function parseStructuralAnalysis(
    htmlScene: string
): StructuralAnalysisResult | null {
    try {
        const match = htmlScene.match(ANALYSIS_REGEX);
        if (!match || !match[1]) {
            // No analysis found - treat as unknown stability
            return null;
        }

        const jsonString = match[1].trim();
        const parsed = JSON.parse(jsonString) as Partial<StructuralAnalysisResult>;

        // Validate required fields
        if (typeof parsed.isStable !== 'boolean') {
            console.warn('[parseStructuralAnalysis] Missing isStable field');
            return null;
        }

        // Validate issues array if present
        const issues: StructuralIssue[] = [];
        if (Array.isArray(parsed.issues)) {
            for (const issue of parsed.issues) {
                if (isValidIssue(issue)) {
                    issues.push(issue);
                } else {
                    console.warn('[parseStructuralAnalysis] Invalid issue object:', issue);
                }
            }
        }

        // Return validated result with defaults for missing optional fields
        return {
            isStable: parsed.isStable,
            issues,
            overallScore:
                typeof parsed.overallScore === 'number'
                    ? Math.max(0, Math.min(100, parsed.overallScore)) // Clamp to 0-100
                    : parsed.isStable
                        ? 100
                        : 50,
            summary:
                typeof parsed.summary === 'string'
                    ? parsed.summary
                    : parsed.isStable
                        ? 'Model appears stable.'
                        : 'Model may have structural issues.',
        };
    } catch (error) {
        console.warn('[parseStructuralAnalysis] Failed to parse:', error);
        return null;
    }
}

/**
 * Strips the structural analysis comment from the HTML scene.
 * Useful for cleaner storage or display.
 *
 * @param htmlScene - The complete HTML scene with embedded analysis
 * @returns The HTML scene without the analysis comment
 */
export function extractCleanHtml(htmlScene: string): string {
    return htmlScene.replace(ANALYSIS_REGEX, '').trim();
}

/**
 * Checks if an HTML scene contains a structural analysis comment.
 *
 * @param htmlScene - The HTML scene to check
 * @returns True if the scene contains a STRUCTURAL_ANALYSIS comment
 */
export function hasStructuralAnalysis(htmlScene: string): boolean {
    return ANALYSIS_REGEX.test(htmlScene);
}
